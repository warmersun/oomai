%import common.WS
%ignore WS
// ---------- Keywords (case-insensitive) ----------
MATCH: /match/i
OPTIONAL: /optional/i
UNWIND: /unwind/i
AS: /as/i
WITH: /with/i // clause
RETURN: /return/i
UNION: /union/i
ALL: /all/i
DISTINCT: /distinct/i
WHERE: /where/i
ORDER: /order/i
BY: /by/i
ASC: /asc/i
ASCENDING: /ascending/i
DESC: /desc/i
DESCENDING: /descending/i
SKIP: /skip/i
LIMIT: /limit/i
SHORTESTPATH: /shortestpath/i
ALLSHORTESTPATHS: /allshortestpaths/i
IS: /is/i
OR: /or/i
XOR: /xor/i
AND: /and/i
NOT: /not/i
STARTS: /starts/i
WITH_KW: /with/i // for STARTS/ENDS WITH (disambiguates WITH clause)
ENDS: /ends/i
CONTAINS: /contains/i
IN: /in/i
NULL: /null/i
TRUE: /true/i
FALSE: /false/i
COUNT: /count/i
CASE: /case/i
WHEN: /when/i
THEN: /then/i
ELSE: /else/i
END: /end/i
EXISTS: /exists/i
REDUCE: /reduce/i
ANY: /any/i
SINGLE: /single/i
NONE: /none/i
// ---------- Safe built-in function names (pure) ----------
ABS: /abs/i
COALESCE: /coalesce/i
TOSTRING: /toString/i
TOINTEGER: /toInteger/i
TOFLOAT: /toFloat/i
LENGTH: /length/i
SIZE: /size/i
IDF: /id/i
LABELS: /labels/i
TYPE: /type/i
STARTNODE: /startNode/i
ENDNODE: /endNode/i
HEAD: /head/i
LAST: /last/i
TAIL: /tail/i
RANGE: /range/i
SUBSTRING: /substring/i
REPLACE: /replace/i
TOLOWER: /toLower/i
TOUPPER: /toUpper/i
LEFT: /left/i
RIGHT: /right/i
SPLIT: /split/i
REVERSE: /reverse/i
DATE: /date/i
DATETIME: /datetime/i
LOCALDATETIME: /localdatetime/i
TIME: /time/i
LOCALTIME: /localtime/i
DURATION: /duration/i
TRIM: /trim/i
KEYS: /keys/i
PROPERTIES: /properties/i
ELEMENTID: /elementId/i
NODES: /nodes/i
RELATIONSHIPS: /relationships/i
// ---------- Allow-listed APOC *functions* (no procedures) ----------
APOC_SAFE_FUNCTION: /(?i)apoc\.(?:coll|map|text|number|date|temporal|convert|regex|math|agg)\.[a-zA-Z_]\w*/
// ---------- Literals & identifiers ----------
STRING_LITERAL: /'((?:\\.|''|[^'\\])*)'/ | /"((?:\\.|""|[^"\\])*)"/
DELIMITED_IDENTIFIER: /`((?:``|[^`])*)`/
IDENTIFIER: /[a-zA-Z_]\w*/
UNSIGNED_DECIMAL_INTEGER: /\d+/
SIGNED_NUMERIC_LITERAL: /-?\d+(?:\.\d+)?/ | /-?(?:inf|infinity)/i | /nan/i
// ---------- Start ----------
?start: program
program: statement
statement: composite_statement
// ---------- Statement forms ----------
composite_statement: linear_statement (UNION set_quantifier? linear_statement)*
linear_statement: primitive_statement+ primitive_result_statement?
primitive_statement: primitive_query_statement
primitive_query_statement: match_statement | unwind_statement | with_statement
match_statement: optional_match_statement | simple_match_statement
optional_match_statement: OPTIONAL simple_match_statement
simple_match_statement: MATCH graph_pattern_binding_table
unwind_statement: UNWIND value_expression AS binding_variable
// WHERE normally precedes ORDER BY in Cypher; keep that order here
with_statement: WITH return_statement_body where_clause? order_by_and_page_clause?
primitive_result_statement: return_statement
return_statement: RETURN return_statement_body order_by_and_page_clause?
return_statement_body: set_quantifier? return_item_list
return_item_list: ("*" | return_item) ("," return_item)*
return_item: value_expression return_item_alias?
return_item_alias: AS identifier
order_by_and_page_clause: order_by_clause offset_clause? limit_clause?
                        | offset_clause limit_clause?
                        | limit_clause
order_by_clause: ORDER BY sort_specification_list
sort_specification_list: sort_specification ("," sort_specification)*
sort_specification: sort_key ordering_specification?
sort_key: value_expression
ordering_specification: ascending_order | descending_order
ascending_order: ASC | ASCENDING
descending_order: DESC | DESCENDING
offset_clause: SKIP value_expression
limit_clause: LIMIT value_expression
graph_pattern_binding_table: graph_pattern
where_clause: WHERE search_condition
set_quantifier: ALL | DISTINCT
// ---------- Patterns ----------
graph_pattern: path_pattern_list graph_pattern_where_clause?
path_pattern_list: path_pattern ("," path_pattern)*
graph_pattern_where_clause: where_clause
path_pattern: path_variable_declaration? path_pattern_expression
path_variable_declaration: binding_variable "="
path_pattern_expression: path_term | legacy_shortest_path_pattern
legacy_shortest_path_pattern: (SHORTESTPATH | ALLSHORTESTPATHS) "(" node_pattern relationship_pattern node_pattern ")"
path_term: path_factor+
path_factor: path_primary | path_primary graph_pattern_quantifier
path_primary: element_pattern | "(" subpath_variable_declaration? path_pattern_expression parenthesized_path_pattern_where_clause? ")"
subpath_variable_declaration: binding_variable "="
parenthesized_path_pattern_where_clause: WHERE value_expression
element_pattern: node_pattern | relationship_pattern
node_pattern: "(" node_pattern_filler? ")"
node_pattern_filler: binding_variable is_node_label_expression? element_pattern_predicate?
                   | is_node_label_expression element_pattern_predicate?
                   | element_pattern_predicate
element_pattern_predicate: element_pattern_where_clause | element_property_specification
element_pattern_where_clause: WHERE value_expression
element_property_specification: "{" property_key_value_pair_list "}"
property_key_value_pair_list: property_key_value_pair ("," property_key_value_pair)*
property_key_value_pair: property_name ":" value_expression
relationship_pattern: full_relationship_pattern
full_relationship_pattern: full_relationship_pointing_left
                         | full_relationship_pointing_right
                         | full_relationship_left_or_right
                         | full_relationship_any_direction
full_relationship_pointing_left: "<" "-" ("[" relationship_pattern_filler? "]")? "-"
full_relationship_pointing_right: "-" ("[" relationship_pattern_filler? "]")? "-" ">"
full_relationship_left_or_right: "<" "-" ("[" relationship_pattern_filler? "]")? "-" ">"
full_relationship_any_direction: "-" ("[" relationship_pattern_filler? "]")? "-"
relationship_pattern_filler: binding_variable is_relationship_label_expression? path_length? element_pattern_predicate?
                           | is_relationship_label_expression path_length? element_pattern_predicate?
                           | path_length element_pattern_predicate?
                           | element_pattern_predicate
path_length: "*" (lower_and_upper_bound_path_length | fixed_path_length)?
lower_and_upper_bound_path_length: lower_bound_path_length? ".." upper_bound_path_length?
fixed_path_length: UNSIGNED_DECIMAL_INTEGER
graph_pattern_quantifier: "*" | "+" | "{" UNSIGNED_DECIMAL_INTEGER "}" | "{" lower_bound_path_length? "," upper_bound_path_length? "}"
lower_bound_path_length: UNSIGNED_DECIMAL_INTEGER
upper_bound_path_length: UNSIGNED_DECIMAL_INTEGER
is_node_label_expression: ":" node_label_expression_legacy | is_label_expression
is_relationship_label_expression: ":" relationship_label_expression_legacy | is_label_expression
is_label_expression: (":" | IS) label_expression
node_label_expression_legacy: label_name (":" label_name)*
relationship_label_expression_legacy: label_name ("|" ":" label_name)*
label_expression: label_term | label_expression "|" label_term
label_term: label_factor | label_term "&" label_factor
label_factor: label_primary | "!" label_primary
label_primary: label_name | "(" label_expression ")" | "%"
// ---------- Names ----------
label_name: identifier
property_name: identifier
binding_variable: identifier
identifier: IDENTIFIER | DELIMITED_IDENTIFIER
// ---------- Expressions ----------
value_expression: boolean_value_expression
search_condition: boolean_value_expression
boolean_value_expression: boolean_term_xor
                        | boolean_value_expression OR boolean_term_xor
boolean_term_xor: boolean_term
                | boolean_term_xor XOR boolean_term
boolean_term: boolean_factor
            | boolean_term AND boolean_factor
boolean_factor: NOT* boolean_primary
boolean_primary: pattern_expression | predicate
predicate: comparison_predicate
comparison_predicate: simple_comparison_predicand simple_comparison_predicate_part_2*
simple_comparison_predicand: advanced_comparison_predicand advanced_comparison_predicate_part_2?
simple_comparison_predicate_part_2: simple_comp_op advanced_comparison_predicand
simple_comp_op: "=" | "<>" | "<" | ">" | "<=" | ">="
advanced_comparison_predicand: arithmetic_value_expression
advanced_comparison_predicate_part_2: advanced_comp_op advanced_comparison_predicand
                                   | IS NOT? NULL
                                   | is_label_expression
advanced_comp_op: CONTAINS | IN | "=~" | STARTS WITH_KW | ENDS WITH_KW
arithmetic_value_expression: arithmetic_term
                           | arithmetic_value_expression "+" arithmetic_term
                           | arithmetic_value_expression "-" arithmetic_term
arithmetic_term: arithmetic_factor
               | arithmetic_term "*" arithmetic_factor
               | arithmetic_term "/" arithmetic_factor
               | arithmetic_term "%" arithmetic_factor
arithmetic_factor: arithmetic_unary
                 | arithmetic_factor "^" arithmetic_unary
arithmetic_unary: ("+" | "-")? postfix_expression
postfix_expression: value_expression_primary
                  | postfix_expression postfix_operator
postfix_operator: "." property_name
                | "[" value_expression "]"
                | "[" slicing_from? ".." slicing_to? "]"
slicing_from: value_expression
slicing_to: value_expression
value_expression_primary: "(" value_expression ")" | non_parenthesized_value_expression_primary
non_parenthesized_value_expression_primary: general_parameter_reference
                                          | case_expression
                                          | count_star
                                          | function_invocation
                                          | exists_expression
                                          | map_projection
                                          | list_comprehension
                                          | pattern_comprehension
                                          | reduce_expression
                                          | quantifier_expression
                                          | shortest_path_expression
                                          | value_specification
                                          | binding_variable
case_expression: simple_case | search_case
simple_case: CASE value_expression simple_when_clause+ else_clause? END
search_case: CASE searched_when_clause+ else_clause? END
simple_when_clause: WHEN when_operand_list THEN value_expression
searched_when_clause: WHEN search_condition THEN value_expression
when_operand_list: when_operand ("," when_operand)*
when_operand: value_expression
else_clause: ELSE value_expression
exists_expression: EXISTS "{" graph_pattern "}" | EXISTS "(" value_expression ")"
map_projection: binding_variable "{" map_projection_element_list? "}"
map_projection_element_list: map_projection_element ("," map_projection_element)*
map_projection_element: property_name ":" value_expression
                      | "." property_name
                      | binding_variable
                      | ".*"
list_comprehension: "[" list_element_source list_element_filter_and_projection? "]"
list_element_filter_and_projection: list_element_filter list_element_projection? | list_element_filter
list_element_source: binding_variable IN value_expression
list_element_filter: WHERE value_expression
list_element_projection: "|" value_expression
pattern_comprehension: "[" pattern_source pattern_filter_and_projection "]"
pattern_source: (binding_variable "=")? simple_path_pattern
pattern_filter_and_projection: pattern_filter? pattern_projection
pattern_filter: WHERE value_expression
pattern_projection: "|" value_expression
reduce_expression: REDUCE "(" binding_variable "=" value_expression "," binding_variable IN value_expression "|" value_expression ")"
quantifier_expression: quantifier "(" binding_variable IN value_expression WHERE value_expression ")"
quantifier: ALL | ANY | SINGLE | NONE
// Allow only built-in SAFE_FUNCTIONs and allow-listed APOC functions.
// COUNT(*) has a dedicated rule, but COUNT(expr) also works via SAFE_FUNCTION.
function_invocation: (SAFE_FUNCTION | APOC_SAFE_FUNCTION) "(" set_quantifier? function_argument_list? ")"
SAFE_FUNCTION: ABS | COALESCE | TOSTRING | TOINTEGER | TOFLOAT | LENGTH | SIZE | IDF | LABELS | TYPE
             | STARTNODE | ENDNODE | HEAD | LAST | TAIL | RANGE | SUBSTRING | REPLACE
             | TOLOWER | TOUPPER | LEFT | RIGHT | SPLIT | REVERSE
             | DATE | DATETIME | LOCALDATETIME | TIME | LOCALTIME | DURATION
             | TRIM | COUNT | KEYS | PROPERTIES | ELEMENTID | NODES | RELATIONSHIPS
function_argument_list: function_argument ("," function_argument)*
function_argument: value_expression
count_star: COUNT "(" "*" ")"
pattern_expression: simple_path_pattern
shortest_path_expression: legacy_shortest_path_pattern
simple_path_pattern: node_pattern (relationship_pattern node_pattern)*
value_specification: literal
                   | general_parameter_reference
                   | "[" list_element_list? "]"
                   | "{" field_list? "}"
list_element_list: value_expression ("," value_expression)*
field_list: field ("," field)*
field: field_name ":" value_expression
literal: SIGNED_NUMERIC_LITERAL
       | boolean_literal
       | STRING_LITERAL
       | NULL
       | "[" list_element_list_literal? "]"
       | "{" field_list_literal? "}"
list_element_list_literal: literal ("," literal)*
field_list_literal: field_literal ("," field_literal)*
field_literal: field_name ":" literal
general_parameter_reference: "$" parameter_name
parameter_name: identifier
field_name: identifier
boolean_literal: TRUE | FALSE